<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Montserrat:wght@700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
    <script src="https://mcadenas4.github.io/robotica/arduino/programacio/arduino.min.js"></script>

    <script>hljs.highlightAll();</script>
    <title>Programaci√≥</title>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(to right, #f8f9fa, #ffe4b5);
            color: #333;
            margin: 0;
            padding: 0;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, #ff3d3d);
            padding: 10px 20px;
            border-bottom: 4px solid #ffdd40;
            z-index: 10;
        }

        .navbar-brand {
            display: flex;
            align-items: center;
            color: #fff !important;
            font-family: 'Montserrat', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
            transition: color 0.2s ease-in-out;
        }

        .navbar-brand:hover {
            color: #000 !important;
        }

        .navbar-brand img {
            margin-right: 15px;
            border-radius: 0;
        }

        .nav-link {
            color: #ffffff !important;
            font-weight: 600;
            margin-right: 15px;
            position: relative;
            transition: color 0.3s ease;
        }

        .nav-link:hover {
            color: #ffdd40 !important;
        }

        .nav-link::after {
            content: '';
            width: 0%;
            height: 3px;
            background-color: #ffdd40;
            position: absolute;
            bottom: -5px;
            left: 0;
            transition: width 0.3s ease;
        }

        .nav-link:hover::after {
            width: 100%;
        }

        .dropdown-menu {
            background-color: #cc3f33;
            border: none;
            border-radius: 10px;
        }

        .dropdown-item {
            color: #ffffff;
            transition: background-color 0.3s ease;
        }

        .dropdown-item:hover {
            background-color: #ff7f50;
            color: #ffffff;
        }

        .content-container {
            margin: 120px auto 50px auto;
            padding: 40px;
            max-width: 900px;
            background-color: #ffffff;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            border-left: 8px solid #ffdd40;
            border-right: 8px solid #ffdd40;
            animation: fadeIn 1.2s ease-in-out;
        }

        h1 {
            color: #ff4500;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        ul {
            list-style-type: none;
            padding-left: 0;
        }

        ul li {
            background-color: #ffe4b5;
            margin-bottom: 10px;
            padding: 10px 15px;
            border-left: 5px solid #ff7f50;
            border-radius: 8px;
            font-size: 1.1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }

        ul li:hover {
            background-color: #f1f3f5;
        }

        a {
            color: #ff4500;
            font-weight: 600;
            transition: color 0.3s ease;
            text-decoration: underline;
        }

        a:hover {
            color: #ff7f50;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .content-container {
                padding: 20px;
            }

            h1 {
                font-size: 2rem;
            }

            .navbar-brand {
                font-size: 1.25rem;
            }

            ul li {
                font-size: 1rem;
            }
        }

        table {
            width: 50%;
            /* Ocupa el 50% de la anchura de la p√°gina */
            border-collapse: collapse;
            /* Evita que aparezcan dobles l√≠neas en las filas */
            margin: 20px auto;
            /* Margen de 20px en la parte superior y centra la tabla */
        }

        th,
        td {
            border: 1px solid #ddd;
            /* A√±ade un borde fino de un p√≠xel de color gris claro a todas las celdas (th y td) */
            padding: 10px;
            /* Espacio interno dentro de cada celda */
            text-align: center;
            /* Centra el texto dentro de cada celda */
        }

        thead {
            background: #f4f4f4;
            /* Cambia el color de fondo del thead a gris claro */
            font-weight: bold;
            /* Hace que la cabecera de la tabla est√© en negrita */
        }

        tbody tr:nth-child(even) {
            /* Aplica estilo a las filas pares */
            background-color: #f9f9f9;
        }

        tbody tr:hover {
            /* Cambia el color de fondo al pasar el rat√≥n por encima */
            background-color: #e2e2e2;
        }

        .button-container {
            display: flex;
            justify-content: center;
            align-items: center;
            left: 50%;
            background: linear-gradient(135deg, #ffe0b2, #ffccbc);
            /* Fondo degradado */
        }

        .custom-button {
            background-color: #e63946;
            color: white;
            border: none;
            padding: 18px 36px;
            /* Bot√≥n m√°s grande */
            font-size: 20px;
            font-family: 'Arial', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 50px;
            /* Bordes m√°s redondeados */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .custom-button:hover {
            background-color: #ff6f61;
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        pre {
            background: #f4f4f4;
            padding: 10px;
            overflow-x: auto;
            position: relative;
        }

        code {
            font-family: monospace;
        }

        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>

<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg">
        <div class="container-fluid">
            <a class="navbar-brand" href="https://mcadenas4.github.io">
                <img src="https://mcadenas4.github.io/logo.png" alt="Logo" width="50">
                Web de Mart√≠
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul.n class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="https://mcadenas4.github.io">Inici</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                            data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                            Programaci√≥
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://mcadenas4.github.io/cara">Cara interactiva</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/ocell">Ocell</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/wepray">We Pray</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/coldplay">Coldplay</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/python">Python</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/astronomia">Astronomia</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/openair">Openair</a>
                        </div>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown2" role="button"
                            data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                            Rob√≤tica
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown2">
                            <a class="dropdown-item" href="https://mcadenas4.github.io/robotica/cdirecta">Cinem√†tica
                                directa</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/robotica/cinversa">Cinem√†tica
                                inversa</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/robotica/coldplay">Coldplay</a>
                            <a class="dropdown-item" href="https://mcadenas4.github.io/robotica/arduino">Arduino</a>
                        </div>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="https://mcadenas4.github.io/enlla√ßos">Enlla√ßos</a>
                    </li>
                </ul.n>
            </div>
        </div>
    </nav>

    <div class="content-container">
        <h3>El meu primer codi: Blink</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//El meu primer codi: Blink
void setup() { //Codi que s'executa una vegada i √©s la configuraci√≥.
  pinMode(13, OUTPUT); //Estem dient que el pin 13 √©s una sortida de corrent o OUTPUT on puc 
    // connectar un led.
}

void loop() { //√âs un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una 
    // instrucci√≥ de parada.
 digitalWrite(13, HIGH); // <b>digitalWrite</b> √©s una sortida digital i permet encendre i apagar
    // Nom√©s t√© 2 valors, HIGH i LOW (Enc√®s i apagat)
 delay(500);//√âs el temps en milisegons que ha d'estar, en aquest cas enc√®s.
 digitalWrite(13, LOW);//Aqui <b>digitalWrite</b> fa que s'apagui
 delay(500);
}
    </code></pre>

    </div>

    <div class="content-container">
        <h3>Codi Blink amb un condicional</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Codi Blink amb un condicional
        
int ledPin = 13;
int delayPeriod = 100;
        
void setup() {
    pinMode(ledPin, OUTPUT);
}
        
void loop() {
    digitalWrite(ledPin, HIGH);
    delay(delayPeriod);
    digitalWrite(ledPin, LOW);
    delay(delayPeriod);
    delayPeriod = delayPeriod + 100; //Augmenta el temps 100 milisegons cada vegada
    if (delayPeriod == 1000) { //Quan arriba a 1000 milisegons torna a comen√ßar, aix√≤ significa que quan arriba a 1000 torna a comen√ßar 
        //perqu√® hem posat que el delayPeriod sigui 100 de nou. 
        //Cada vegada √©s m√©s lent perqu√® el temps que triga en encendre i apagar-se √©s major.
        //Si vulgues que cada vegada sigui m√©s r√†pid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de 
        //int delayPeriod = 1000, a final de codi posar el menys a "delayPeriod = delayPeriod - 100", i finalment canviar el condicional per:
        //if (delayPeriod == 100); delayPeriod = 1000;
        //Si vull que el canvi sigui m√©s lent s'hauria de posar un n√∫mero m√©s alt en "delayPeriod = delayPeriod + X"
        //Si vull que el canvi sigui m√©s r√†pid s'hauria de posar un n√∫mero m√©s petit en "delayPeriod = delayPeriod + X"
    delayPeriod = 100;
    }
}
    </code></pre>

    </div>
    <div class="content-container">
        <h3>Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)
            void setup() {
              Serial.begin(9600);//Hem de connectar l'Arduino a la consola s√®rie a 9600 bauds, que s√≥n 9600 s√≠mbols per segon
                //I poden ser aproximadament 9600 bits per segon, per√≤, en alguns casos, necessitem m√©s d'un bit per un s√≠mbol
              int a = 2;
              int b = 2;
              int c = a + b;//Llenguatge arduino accepta les operacions matem√†tiques b√†siques
              Serial.println(c); 
            }
            void loop() {}
            </code></pre>
    </div>
    <div class="content-container">
        <h3>Exemple de temperatura amb operacions matem√†tiques</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Exemple de temperatura amb operacions matem√†tiques
            
            void setup() {
              Serial.begin(9600);
              int degC = 20; //Representa que el sensor ja ha agafat 20 graus i els volem convertir a Fahrenheit
              int degF;
              degF = degC * 9 / 5 + 32;
              Serial.println(degF); //Fes una impressi√≥ a la consola de l'ordinador en una l√≠nea println el valor de la variable fahrenheit.
            }
            void loop(){}
            </code></pre>
    </div>
    <div class="content-container">
        <p>En el seg√ºent codi podem veure com definir unes variables globals i les apliquem moltes vegades repetides
            dins del mateix codi. √âs un codi molt repetitiu.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}
</code></pre>
    </div>
    <div class="content-container">
        <p> Amb el seg√ºent codi, aconseguim el mateix resultat que m√©s amunt, es a dir,
            encendre i apagar 20 vegades amb un delay de 250 milisegons, per√≥ no ho escribim 20
            vegades, si no que fem un cicle for.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 02_08_blik_20_for
        
        int ledPin = 13;
        int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          for (int i = 0; i < 20; i ++) { //Dintre del cicle for, tenim les condicions que ha de complir el cicle
              //que s√≥n des de i = 0 fins a i = 20, ves augmentant un en un. O sigui i++ que es el mateix que i = i + 1
              //Si volgu√©s podria canviar les condicions. fent que els numeros augmentesin diferent
              //(Per exemple i = i + 5)
              
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
          }
         delay(3000);
        }
        </code></pre>
    </div>
    <div class="content-container">
        <p> En el codi anterior, hem dit que repeteixi 20 vegades per√≤ es repeteix infinites vegades perqu√© es repeteix
            20 vegades en un void loop. En el seg√ºent codi, posarem un contador i quan arribi a 20 repeticions s'aturar√†
        </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        // 02_09_blink_20_loop (Aqui es nota perqu√©)
        
        int ledPin = 13;
        int delayPeriod = 100;
        int count = 0;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
         digitalWrite(ledPin, HIGH);
         delay(delayPeriod);
         digitalWrite(ledPin, LOW);
         delay(delayPeriod);
         count ++; //"Count" es una variable global que podria ser local, perqu√® nom√©s afecta al loop.
            //si escric "int count; count ++;" estaria definint una variable local dintre del loop, i no es pot usar en una altre funci√≥ que jo defineixi o
            //al setup
         if (count == 20) { //Quan el comtador arriba a 20 deixa de fer parpadeigs de 100 milisegons i fa una aturada de 3 segons abans de tornar a comen√ßar
           count = 0;
           delay(3000);
         }
        }
         // Dos iguals vol dir que es exactament igual. Si posem 3 iguals "===" es una comparaci√≥ estricta es a dir una comparaci√≥
        // estricta, que compara tamb√© el tipus de variable. Si posem un igual "=" √©s una assignaci√≥ que pot ser temporal o constant
        // si es posa "const" davant es 
        </code></pre>
    </div>
    <div class="content-container">
        <p> El seg√ºent codi es el primer exemple de creaci√≥ d'una funci√≥. Una funci√≥ es com un programa dins dins d'un
            programa.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_01_blink_function
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        // Aquest codi es el principal, anomenat com a "main" en alguns llenguatges. √âs el que s'aplica continuadament. En aquest cas el "void loop()"
        // el loop repeteix 20 vegades el flash.
        // Com cridem una funci√≥?
        // Nom√©s cal posar el nom de la funci√≥ dintre del loop per cridar-la i que s'executi sempre.
        void loop() {
          for (int i = 0; i < 20; i ++) {
            flash();
          }
         delay(3000);
        }
        // per crear una funci√≥ nom√©s cal escriure el nom de la funci√≥ i uns parentesis. Si hagu√©s alguna cosa entre parentesi
        //serian els parametres o arguments de la funci√≥. La paraula "void" en aquest cas es equivalent a la paraula "function" de javascript.
        //triem un nom explicatiu del que fa la funci√≥, i dintre de les claus posem les linees de codi que s'han d'executar quan la cridem pel seu
        //nom dintre del void loop (per exemple). 
        void flash() { 
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
        }
        </code></pre>
    </div>
    <div class="content-container">
        <p>A continuaci√≥ veurem el codi flash per√≤ amb par√†metres. </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_functrion_params
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          flash(20, delayPeriod);
          delay(3000);
        }
        // Podem veure que la funci√≥ te dos par√†metres que son 2 nombres enters i que s'anomenen "numFlashes" i "d"
        // numFlashes no esta definit com a variable global, √©s una variable local definida dins de la funci√≥ "flash"
        // i no te un valor predeterminat, nom√©s ha de complir que sigui un valor enter. El mateix per a la variable "d"
        void flash(int numFlashes, int d) {
            for (int i = 0; i &lt; numFlashes; i++) {
            digitalWrite(ledPin, HIGH);
            delay(d);
            digitalWrite(ledPin, LOW);
            delay(d);
            }
            }

        </code></pre>
    </div>

    <div class="content-container">
        <h1>Funcions en Arduino</h1>
        <p>Les funcions d'arduino s√≥n semblants a les funcions que veiem a cinem√†tica directa i inversa. En el cas de la
            cinem√†tica rob√≤tica
            utilitzavem funcions Javascript dintre d'un codi HTML. Avans cada funci√≥ com per exemple, calculatePosition
            () era una funci√≥
            sense arguments o par√†metres que estava identificada amb un bloc de codianomenat function i s'executava quan
            clicavem un bot√≥.
            Dintre d'aquest bloc hi havien instruccions que permeten fer c√†lculs matem√†tics. En el seg√ºent codi
            d'arduino, tenim una funcion
            flash amb dos per√†metres que eren n√∫meros enters anomenat ledPin i de delayPeriod que identifiquen el pin
            que est√† connectat i el
            temps que ha d'estar enc√®s o apagat.
        </p>
        <p> Ara farem que un bucle for ss'executi 20 o x vegades dintre d'unbucle for localitzat dintre d'un bucle
            infinit loop. Ho aconseguim
            amb la paraula clau static, que fa que una variable s'inicialitzi una vegada que correm el codi i mai m√©s.
            La paraula static es deriva
            del llenguatge C i Arduino √©s un derviat de C++ i Processing, </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_20_faulty

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
            </code></pre>
    </div>

    <div class="content-container">
        <h1>Arrays i Strings</h1>
        <p>Una Array √©s una forma de contenir un llistat de valors, moltes vegades s√≥n valors enters i s'accedeix amb
            ells per la
            seva posici√≥, sent la primera posici√≥ [0] del array o element 0. El codi seg√ºent el que fa √©s a la primera
            linia defineix una
            array amb 9 valors, i els imprimeix en el monitor s√®rie els seus valors. Ser√† √∫til pel nostre codi morse.
        </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {

}
            </code></pre>
    </div>

    <div class="content-container">
        <p>El codi seg√ºent ja √©s un codi morse, perqu√® combina una array, un bucle for que llegeix l'array i l'aplica a
            la funci√≥ flash,
            d'aquesta forma √©s com si escrivis flash(200), flash(200), flash(200), flash(500), flash(500), flash(500),
            flash(200), flash(200), flash(200).
        </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
        </code></pre>
    </div>

    <div class="content-container">
        <p>Puc crear una funci√≥ que em serveix per quatre lletres i nom√®s quan la crido he de posar el n√∫mero de
            repeticions com
            par√†metres o arguments</p>
    </div>

    <div class="content-container">
        <h1>Normes internacionals de codi Morse</h1>
        <ul>
            <li>Una l√≠nia (dash) √©s igual a tres punts</li>
            <li>L'espai entre les parts d'una meteixa lletra √©s igual a un punt (dot). (S = ¬∑¬∑¬∑, l'espai entre cada punt
                √©s un punt)</li>
            <li>L'espai entre dues lletres de la mateixa paraula s√≥n tres punts (Per exemple entre las S i la O de SOS)
            </li>
            <li>L'espai entre dues parules √©s igual a set punts (Pa ¬∑¬∑¬∑¬∑¬∑¬∑¬∑ tom√†quet)</li>
        </ul>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                void eosz (int numFlashes) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(200);
                        digitalWrite(ledPin, LOW);
                        delay(200);
                    }
                }

                void loop(){
                    eosz(1); // Aix√≤ √©s la lletra e
                    eosz(3); // Aix√≤ √©s la lletra s
                    eosz(2); // Aix√≤ √©s la lletra o
                }
            </code></pre>

        <p>Crearem una funci√≥ que ser√† v√†lida pels punts repetits i per les linies repetides amb dos par√†ametres.</p>

        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


                void eosztmo (int numFlashes, int d) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(d);
                        digitalWrite(ledPin, LOW);
                        delay(d);
                    }
                }

                void loop(){
                    eosztmo(1, 600); //Aix√≤ √©s la t
                    eosztmo(3, 600); //Aix√≤ √©s la o
                    eosztmo(3, 200); //Aix√≤ √©s la s
                    eosztmo(1, 200); //Aix√≤ √©s la e
                }
            </code></pre>
    </div>
    <div class="content-container">
        <h1>Codi ASCII</h1>
        <p>L'objectiu del codi seg√ºent √©s entendre que les cadenes o strings s√≥n conjunts de car√†cters ASCII i podem
            accedir
            amb ells amb arrays que esta formats per par√®ntesis quadrats i el primer element √©s el 0. En llenguatge C i
            derivats
            del C com Arduino podem utilitzar punters o pointers que permeten apuntar a un element. En python o
            JavaScript no hi
            ha punters.</p>
        <p>A continuaci√≥ veuras els caracter ASCII en una taula, que son els utilitzats en els strings o cadenes</p>
        <p>La taula seg√ºent est√† basada en un codi binari de 7 bits, perque 2 elevat a 7 (2^7) es 128, hi hauran desde 0
            a
            127 car√†cters diferents</p>
        <table>
            <thead>
                <tr>
                    <th>ASCII</th>
                    <th>DECIMAL</th>
                    <th>BINARI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>A-Z</td>
                    <td>65-90</td>
                    <td>1000001-1011010</td>
                </tr>
                <tr>
                    <td>a-z</td>
                    <td>97-122</td>
                    <td>1100001-1111010</td>
                </tr>
                <tr>
                    <td>0-9</td>
                    <td>48-57</td>
                    <td>110000-111001</td>
                </tr>
                <tr>
                    <td>espai</td>
                    <td>32</td>
                    <td>100000</td>
                </tr>
            </tbody>
            </th>
        </table>
        <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb
            l'objectiu
            d'intercambiar informaci√≥ amb ordinadors</p>
        <p>UTF8 √©s un sistema Unicode Transformation Format que permet escriure m√©s d'un mili√≥ de car√†cters diferents
            ‚ÄúüôÇ‚Äù U+1F642</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                // sketch 05-03

                char message[] = "Hello";
                
                void setup() {
                  Serial.begin(9600);
                  message[0] = 'h';
                }
                
                void loop() {
                  Serial.println(message);
                  delay(1000);
                }
            </code></pre>

    </div>
    <div class="content-container">
        <h3>Import√†ncia dels punters + Exemple de codi Morse</h3>
        <p>Hi ha llenguatges amb i sense punters.</p>
        <ul>
            <li>Exemples de llenguatges amb punters: C i els seus derivats com arduino</li>
            <li>Exemples de llenguatges sense punters: Python i Javascript</li>
        </ul>
        <p>El punter llegeix el contingut d'una adre√ßa de memoria i tambe la posici√≥ de la mateixa adre√ßa i pot
            manipular-la. Hi ha posicions d'adre√ßes especials, com els sectors d'arrancada.</p>
        <p>El punter serveix per tenir el control total per part del programador de la memoria i els recursos de
            l'ordinador</p>
        <p>El "Problema" que te es que pot provocar errors a la memoria o accesos no permesos si no saps com fer
            funcionar correctament el punter</p>
        <p>Els dos s√≠mbols per utilitzar punters son: L'arterisc "*", que serveix per llegir el contingut de l'adre√ßa de
            memoria. I l'ampersand "&", que llegieix la posici√≥ de l'adre√ßa de memoria</p>
        <p>La memoria de l'ordinador la podem imaginar com caixes d'una llista on cada caixa te un valor unic assignat
            en hexadecimal que comen√ßa per 0x. Cada caixa te un contingut que pot ser buit (0) o pot contenir un valor
        </p>

        <h4>Operacions avan√ßades amb punters</h4>
        <ul>
            <li><b>Acc√©s directe a la memoria:</b> Permet modificar valors en posicions especifiques.</li>
            <li><b>Manipulaci√≥ eficient d'arrays i strings (cadenes):</b> L'array esencialment es una llista adre√ßes amb
                principi i final amb un punter al primer element.</li>
            <li><b>Passar grans quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva
                adre√ßa, estalviant memoria i temps. Aquest es un dels motius per els que C i derivats son mes rapids que
                python o JS.</li>
            <li><b>Creaci√≥ d'estructures dinamiques:</b> Es pot crear coses com grafics o llistes enlla√ßades de forma
                facil</li>
            <li><b>Interacci√≥ amb microcontroladors senzilla:</b> Els microcontroladors utilitzen llenguatges de baix
                nivell (low-level languages) que son mes properes al hardware. Encara que, gracies a l'augment de la
                memoria, s'han pogut crear llenguatges com micropython o circutpython.</li>
        </ul>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// Al principi del codi, abans de la funci√≥ de configuraci√≥ "setup" i la funci√≥ principal 
// "loop" que s'executa continuament, hem d'escriure sempre variables o constants.
// A m√©s, al principi del codi trobem les constants i variables globals, anomenades aix√≠ perqu√® es poden cridar
// o executar des de qualsevol part del codi, a diferencia de les variables locals que es 
// defineixen i s'utilitzen dintre de la mateixa funci√≥ "loop" o una funci√≥ addicional.
// Davant de les variables i constants globals hauriem d'afegir les biblioteques necess√†ries per 
// fer funcionar el nostre codi ( amb "#include <nom_biblioteca.h> ) l'extensi√≥ "h" deriva de C
// i significa "biblioteca de headers" o encap√ßalaments.        
const int ledPin = 13;
const int dotDelay = 200
                
// "const" vol dir que la variable no es modificar√† dins del codi, "int" vol dir integer, o sigui
// que el nombre que agafem haur√† de ser enter, ja que els pins tenen n√∫meros enters. El pin 13
// √©s especial, t√© una resist√®ncia interna en el cas d'Arduino uno que permet connectar directament
// un led, perqu√® est√† al costat del pin GND i puc clavar o connectar un led sense cap circuit o placa.
// "ledPin" √©s una variable constant i s'anomena aix√≠ per l'usuari, utilitzant camelCase i referint-nos
// al que fa aquest pin.
char* letters[] = {
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};
// M√©s amunt i m√©s abaix tinc dos arrays composats cadascun d'ells per arrays interns i cada array intern
// est√† composat de caracters que nom√©s poden ser "." o "-".
// Quan jo crido "letter[0]" el que obtinc ".-" o sigui, la lletra A en codi Morse.
// Aquesta forma de treballar √©s molt dolenta, des d'un punt de vista d'efici√®ncia perqu√® estic utilitzant.
// un byte ( un byte s√≥n 8 bits ) sencer per cada punt o ratlla. 
// Un bit √©s un valor de 0 o 1 i aix√≤ es podria utilitzar per fer els punts o ratlles perqu√® els dos valors
// s√≥n dos estats, o 0 o 1, es podria asignar el 0 al punt i la ratlla l'1, fent-ho m√©s eficient.
// En un byte hi han 8 bits i per aix√≤ es podrien fer 256 caracters diferents.
// Quants bytes de mem√≤ria necesitarem utilitzant bytes o bits per codificar Morse?
// Aproximadament el Morse t√© uns 109 punts o ratlles pels n√∫meros o lletres, de la manera m√©s eficient
// tindriem un √∫s de 14 bytes i de la manera menys eficient 872 bytes.
// Hem de tenir en compte
// De fet ASCII utilitza 7 bits per crear 128 caracters ( de 0 a 127 ).
// "*" √©s molt important, ja que ens indica que √©s un punter, "[]" ens indica que √©s una array,
//  "numbers" m'indica el valor de l'array, i char m'indica el tipus d'element ( que s√≥n caracters ) que hi ha dins
// de l'array.
// L'array de sota es diu numbers per√≤ est√† constituit per caracters, perqu√® tant els n√∫meros com les lletres
// estan constituides per "." o "-" que s√≥n caracters
    char* numbers[] = {
    "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};
                
void setup() {
    pinMode(ledPin, OUTPUT);
    Serial.begin(9600);
    // En el setup o configuraci√≥ del microcontrolador indiquem que el pin 13 que ara es diu "ledPin" sigui √©s una sortida o "Output"
    // Indiquem a l'arduino que es comuniqui amb l'ordinador a traves del port serial o serie i comenci a una velocitat de 
    // 9600 bauds o simbols/segon que s√≥n aprox. 9600 bits/segon.
}
                  
                
void loop() {
    // El loop √©s el codi principal, i el que el seu nom indica que es repeteix sense parar en un "loop".
    // "char" signica que utilitzem una variable de tipus caracter i l'anomenem "ch".
    // "Serial.available" significa si est√† disponible la comunicaci√≥ serie o "serial monitor" que comunica  el microcontrolador
    // arduino amb el nostre ordinador o dispositiu.
    // La comunicaci√≥ entre arduino i l'ordinador √©s complexa: 
    // Primer pas: l'ordinador envia dades al monitor serie a traves de l'USB per un mecanisme que s'anomena "USB to Serial"
    // Segon pas: la transformaci√≥ anterior d'USB to Serial la fa un xip especial dintre d'Arduino.
    // Tercer pas: les dades en format serie arriben a una part del microcontrolador anomenada UART que significa 
    // "Universal Asynchronous Receiver Transmiter"
    // Quart pas: l'UART envia les dades que rep a una mem√≤ria temporal o "buffer" que pot enmagatzemar 128 bytes fins que s'elimina en
    // el moment que es llegeix -Soy Marticon -by Miguel Angel
    // La funci√≥ serial available retorna el n√∫mero de bytes de dades en el "buffer" que estan esperant per ser llegits. Si no hi ha cap missatge
    // esperant a ser llegit, la funci√≥ retorna a 0
    // La funci√≥ "Serial.read" el que fa √©s llegir el primer o el seg√ºent caracter disponible i l'emmagatzema a la variable "ch"
    // El s√≠mbol >= o <= s'utilitza per comparar amb el n√∫mero d'ASCII que correspon per la lletra "a" per tant, podriem canviar l'a
    // pel n√∫mero 97 i la z √©s el n√∫mero 122.
    // Els altres caracters que podem canviar serien 'A' pel n√∫mero 65, Z pel n√∫mero 90.
    // El caracter '0' correspon al n√∫mero 48 i el caracter '9' correspon al n√∫mero 57.
    // El caracter ' ' correspon al n√∫mero 32.
    // Els condicionals que hi han dintre del condicional general "Serial.avaliable" el que fan √©s dir es que si el caracter √©s 
    // entre la a i la z le restes el valor -a
    // Imaginem que la primera lletra √©s una 'c', que equival al n√∫mero 99, llavors si li restem la 'a' que √©s 97 quedaria un n√∫mero 2.
    // El n√∫mero 2 est√† dintre d'un ([]) √©s a dir, dintre d'una array i correspondria al tercer element de l'array de les lletres.
    // Aquest tercer element √©s "-.-."
    // Un altre exemple seria la 'H' estaria avaluat en un altre condicional, el de les mayuscules, aquest caracter equival 
    // al n√∫mero 72, i li he de restar la 'A' que equival al n√∫mero 65, per tant ch - 'A' √©s 7 que √©s el vuit√© element de l'array
    // de maj√∫scula [7] i letters[7] √©s "...." .
    // Per qu√© s'ha de restar?
    // Per conexier la posici√≥ de la lletra a l'array, perqu√® hem possat l'array ordenat 
    // des de la 'a' fins la 'z' i des de la 'A' fins la 'Z'
    // Ara tenim el n√∫mero per exemple letters[7] igual a "...." i el que volem √©s aplicar una funi√≥.
    char ch;
    if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
    }
}
                

// El void flashSequence() √©s una funci√≥ que rep un argument
// El que fa amb aquest argument √©s utilitzar un punter i seguir la seq√º√®ncia que es troba amb letters[7]
// que √©s "....", aquest quatre car√†cters o punts s√≥n una seq√º√®ncia de car√†cters ordenats gr√†cies al punter*
// El codi se√ºents el que fa √©s amb la posici√≥ 'i' inicial de 0 que √©s el pointer al principi de l'array "...."
// I el que fa √©s que mentre (while) aquest element 'i' de la seq√º√®ncia no sigui (!) = NULL, √©s a dir mentre
// hi hagi un car√†cter, crida una funci√≥ diferent anomenda "flashDotOrDash()" que rep com a argument el valor de 'i'
// concret en aquella seq√º√®ncia
// Despre√©s de rebre'l passa el seg√ºent valor de 'i', si la 'i' era el primer ".", la i++ primera o i = i+1 √©s 
// el segon punt ".". I aix√≠ fins al cinqu√® punt que s'atura tot, perqu√® √©s NULL, √©s a dir, no hi ha un cinqu√® punt.
// El delay serveiix per deixar espai entre lletres o sequences.
void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
}
    delay(dotDelay * 3);    // gap between letters
}
                
// La funci√≥ "flashSequence" que llegeix una determinada lletra que rep com a argument, letters[7] i reconeix que 
// est√† formada per "...." i crida la funci√≥ "flashDotOrDash" fins que s'acaben els punts o ratjes i deixa un espai
// al final per indicar que √©s una lletra.
// La funci√≥ "flashDorOrDash" t√© un parametre intern anomenat "dotOrDash". Aquesta funci√≥ sempre encen un led, i sempre
// el deixa un temps enc√©s o delay. En el cas que sigui una ratlla, el fa 3 vegades m√©s llarg que un punt, gracies
// a un condicional "if" o en cas contrari "else". No diem si √©s una ratlla, diem si no √©s un punt
void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
// El "loop" √©s un bucle i continuament crida a la funci√≥ "flashSequence" que el que fa √©s llegir cada lletra i convertirles
// en punts i ratlles, aquesta funci√≥ crida a la funci√≥ "flashDotOrDash" continuament que fa que s'encenguin els leds segon
// els punts i ratlles. Sempre hem de dividir un codi en diverses funcions, primer per fer-lo m√©s modular i entendre que fa 
// cada funci√≥ i a m√©s ens fa m√©s facil el manteniment i canvis futurs.
</code></pre>
</div>
<div class="content-container">

<h2>Input i Output: Entrades i sortides</h2>
<p>Les entrades i sortdes poden ser de dues maneres diferents, digitals o anal√≤giques, les digitals poden 
ser de 0 voltso de 3,3 volts i en altres plaques arduino, poden ser 0 volts i 5 volts. Les anal√≤giques
serien graduals, de 0 a 3,3 volts o 5 volts en 2**n pasos, sent "n" el n√∫mero de bits.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int outPin = 3;
// pinMode √©s una funci√≥ predeterminada o "built-in", vol dir que est√† predefinida en el llenguatje
// arduino i sempre ha de rebre 2 argument o parametres, el primer sempre ha de ser un n√∫mer enter o "int"
// (integer) que correspon al n√∫mero de pin que volem conectar (en aquet cas 3), el segon argument √©s el mode
// que pot ser OUTPUT que significa sortida, o INPUT que significa entrada, tamb√© existeix INPUT_PULLUP
void setup() {
  pinMode(outPin, OUTPUT);
  Serial.begin(9600); //Miguel Angel
  Serial.println("Enter 1 or 0");
}

void loop() {
  if (Serial.available() > 0) {
    char ch = Serial.read();
    if (ch == '1') {
      digitalWrite(outPin, HIGH);
    }
    else if (ch == '0') {
      digitalWrite(outPin, LOW);
    }
  }
}
</code></pre>
    </div>
    <div class="content-container">
    // Quan tenim una entrada hem de possar mode input i en comptes de fer un digitalWrite que fem a les sortides
    // hem de fer un digitalRead per obtenir l'entrada, que nom√©s pot ser un valor digital de 0 o 1 (binari)
    // Si el voltatge √©s menor a 2,5 volts es traduir√† com un 0, en canvi si √©s superior com un 1
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    
    void setup() {
      pinMode(inputPin, INPUT);
      Serial.begin(9600);
    }
    
    void loop() {
      int reading = digitalRead(inputPin);
      Serial.println(reading);
      delay(1000);
    }
    </code></pre>  
    </div>
    
    <div class="content-container">
    // El pullup estabilitza la senyal que rep per a que la transcripci√≥ a binari (0 i 1) sigui correcta. Si analitzem el que
    // passa amb un oscil¬∑loscopi (mesura les oscil¬∑lacions de la corrent) si mirem un oscil¬∑loscopi unveurem que hi han 
    // pujades i baixades quan premo el bot√≥ no baixa de forma ideal sin√≥ que t√© alguns pics que es diuen rebots 
    // (bouncing / debouncing) en el cas de debouncing √©s m√©s correcte ja que el senyal per defecte √©s inestable i el que fem
    // √©s estabilitzar-lo -> desrebotar.
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    
    void setup() {
      pinMode(inputPin, INPUT_PULLUP);
      Serial.begin(9600);
    }
    
    void loop() {
      int reading = digitalRead(inputPin);
      Serial.println(reading);
      delay(1000);
    }
    </code></pre>
    </div>

    <div class="content-container">
    // El togger 
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
      pinMode(inputPin, INPUT_PULLUP);
      pinMode(ledPin, OUTPUT);
    }
    
    void loop()  {
      if (digitalRead(inputPin) == LOW) {
         ledValue = ! ledValue;
         digitalWrite(ledPin, ledValue);
      }
    }
    </code></pre>
    </div>
    <div class="content-container">
        <h2>Negaci√≥</h2>
        <p>El signe d'admiraci√≥ "!" significa negar la variable que es posa despr√©s del signe.</p>
<p> Hi ha dos variables inicials, que son constants per definici√≥ del codi. La variable ledPin es el pin el qual conectem
el led, que es 13 normalment. I el pin 5 es un pin on conectem un interruptor per entrada de dades. El pin 5 esta enc√©s per defecte
perque li hem dit que es un input pull-up, significa que l'interruptor deixa pasar la corrent per defecte. Si fos un input nom√©s 
estaria a 0, es a dir, l'interruptor estaria obert. La variable switch open esta al principi amb valor 1 i quan movem el bot√≥, 
l'apaguem perqu√© la variable switchOpen que estava a 1 es transforma a !switchOpen que esta a 0. I si li torno a negar, sortira 1.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13
    void setup() {
     pinMode(ledPin, OUTPUT);
     pinMode(inputPin, INPUT_PULLUP);
    }
    void loop() {
     int switchOpen = digitalRead(inputPin);
     digitalWrite(ledPin, ! switchOpen);
    }
    </code></pre>
<p> Clica a la imatge seg√ºent per veure la simulaci√≥ </p>
<a href = "https://www.tinkercad.com/things/6kmvYJBnQFx-circuit-54-monk" target = "_blank"> <img src = "54.png"> </a>
<p> Toggles. </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;

    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    void loop()  {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
<a href = "https://www.tinkercad.com/things/ijQ7CKiIRbu-circuit-55-monk" target = "_blank"> <img src = "55.png"> </a>

<p>soluci√≥ amb llibreria </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
    }
    }
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
         #include <Bounce2.h>
        const int inputPin = 5;
        const int ledPin = 13;
        int ledValue = LOW;
        Bounce bouncer = Bounce(); 

        void setup() {
        pinMode(inputPin, INPUT_PULLUP);
        pinMode(ledPin, OUTPUT);
        bouncer.attach(inputPin);
        // bouncer.interval(50); // interval in ms
        }

        void loop() {
        if (bouncer.update() && bouncer.read() == LOW) {
          ledValue = ! ledValue;
          digitalWrite(ledPin, ledValue);
        // El rebot de contacte (Contact Bounce) esta present en reles (Interruptors que canvia de estat depenent de l'electricitat), interruptors, contactes de bateria. Tots aquests
        // Estan fets per metalls elastics, de forma que quan yo apreto un interruptor mecanic, el metall rebota diverses vegades sobre el contacte, provocant una inestabilitat al
        // contacte
        }
        }
 </code>
</pre>
<p> Algunes sortides d'arduino i altres microcontroladors s√≥n PWM (Pulse Width Modulation). Com podem veure a la imatge de sota, es tracta
de una modulaci√≥ de l'ample del pols. Es a dir, es modula el temps que es 0 o que es 1, aconseguint que en 0 s'apagui i en 1 s'encengui.
Nosaltres no observem que s'encengui o que s'apagui perque es molt rapid el canvi i la nostra visi√≥ no ens permet veure-ho. Nosaltres veiem
la llum en un percentatge que depen del percentatge de temps que ha estat ences la sortida </p>
<img src = "pwm.jpg">

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600); //Comen√ßa la comunicaci√≥ serie USB entre arduino i l'ordinador a 9600 bauds (s√≥n 9600 s√≠mbols per segon)
    //L'objecte Serial √©s de la classe serial i li apliquem amb la sintaxi del punt el metode begin que t√© com a parametre o argument un n√∫mero enter que correspondr√†als bauds
  Serial.println("Enter Volts 0 to 5"); //Demana que el usuari que entri per la consola o serial monitor de l'arduino IDE un n√∫mero entre 0 i 5
    //Println significa imprimeix una linea i li apliquem en la sintaxi del punt a la classe serial pot rebre diversos parametres, si els posem entre cometes s'escriu tal cual i si no, escriu el valor de la variable.
}

void loop() { //√âs un sistema que no s'atura mai, es repeteix fins que desconecto el arduino
  if (Serial.available() > 0) { //Serial.available √©s un m√®tode que espera car√†cters, major a 0 √©s que hi ha un car√†cter
    float volts = Serial.parseFloat(); //parseFloat √©s una funci√≥ o m√®tode que s'aplica a l'objecte serial i la seva funci√≥ √©s parsejar o analitzar el contingut de car√†cter que arriba per port serial i si √©s de tipus decimal o floating point number (n√∫mero amb coma flotant) o variable tipo float. Les variables float inclouen les variables int o integer n√∫meros sencers. Tamb√© existeix parseInt que nom√©s acceptaria n√∫meros enters.
    //Volt emmagatzema el n√∫mero decimal que escriu el usuari.
    //El float volts que fa? Crea un espai a la memoria del ordinador anomenat volts que haur√† de ser del tipus floating point number que emmagatzemar√† el que li arribi del port serial escrit per l'usuari.
    int pwmValue = volts * 255.0 / 5.0; //Els volts no serveixen directament perqu√® volem no valors entre 0 i 5 sino entre o i 255. √âs entre 0 i 255 perqu√® √©s el n√∫mero de bits (2^8 √©s igual a 256). Faig una regla de 3 i multiplico el valor per 255 i divideixo entre 5.
    //Per exepmle si l'usuari inserta 2,5 tindras 2,5 * 255 / 5 = 127,5. Aquest valor es transformar√† en 127 perqu√® ha de ser integer i es guardar√† en pwm Value.
    analogWrite(outputPin, pwmValue);
  }
}
</code></pre>
<p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Despr√©s de definir
el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escrigui a la consola
del programa Arduino IDE: Enter volts 0-5.</p>
<p> Al loop principal comprova que hi hagi car√†cters escrits a la consola, despr√©s agafa el valor que hem 
donat i el guarda en la variable volts. El valor pot ser en decimals perqu√® posa float ("Floating point number").
El m√®tode parseFloat l'apliquem amb la sintaxi del punt al objecte Serial (Que es posa en maj√∫scula, normalment
seria una classe en maj√∫scula) i agafa el valor de la consola s√®rie</p>
<p> La variable pwmValue √©s entera (int o "integer") i el que fa √©s convertir el valor de volts (0-5) a valors
de 0-255, que √©s el numero de bits (2^8=256). Si fos un ESP32-S3 de 14 bits tal com indica el data
sheet o fulla de caracteristiques de el ESP32-S3la linea de codi seria:
"Serial.println("Enter Volts 0-3.3")
"int pwmValue = volts * 16384.0 / 3.3" </p>

<p> El ESP32-S3 te l'avantatge de tenir m√©s resoluci√≥, es a dir,  pot donar 16384 valors diferents entre 0-3,3 volts
Aix√≥ pot que no es noti en un led, per√≥ es nota en un motor, on l'ESP32 permet accedir a m√©s velocitats diferents. Els
motors poden arribar a 16 bits, que es 2^16 o 65536 valors diferents, depenent del tipus de motor, pot ser observat o no
</p>
</div>
        
    <!-- Scripts necessaris -->

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"></script>
        
</body>
</html>
